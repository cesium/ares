"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformDocumentLinkTarget = exports.register = void 0;
const vscode_uri_1 = require("vscode-uri");
const cancellation_1 = require("../utils/cancellation");
const language_core_1 = require("@volar/language-core");
function register(context) {
    return async (item, token = cancellation_1.NoneCancellationToken) => {
        const data = item.data;
        if (data) {
            const service = context.services[data.serviceIndex];
            if (!service[1].resolveDocumentLink) {
                return item;
            }
            Object.assign(item, data.original);
            item = await service[1].resolveDocumentLink(item, token);
            if (item.target) {
                item.target = transformDocumentLinkTarget(item.target, context);
            }
        }
        return item;
    };
}
exports.register = register;
function transformDocumentLinkTarget(target, context) {
    const targetUri = vscode_uri_1.URI.parse(target);
    const clearUri = targetUri.with({ fragment: '' }).toString();
    const [virtualCode] = context.documents.getVirtualCodeByUri(clearUri);
    if (virtualCode) {
        for (const map of context.documents.getMaps(virtualCode)) {
            if (!map.map.mappings.some(mapping => (0, language_core_1.isDocumentLinkEnabled)(mapping.data))) {
                continue;
            }
            target = map.sourceFileDocument.uri;
            const hash = targetUri.fragment;
            const range = hash.match(/^L(\d+)(,(\d+))?(-L(\d+)(,(\d+))?)?$/);
            if (range) {
                const startLine = Number(range[1]) - 1;
                const startCharacter = Number(range[3] ?? 1) - 1;
                if (range[5] !== undefined) {
                    const endLine = Number(range[5]) - 1;
                    const endCharacter = Number(range[7] ?? 1) - 1;
                    const sourceRange = map.getSourceRange({
                        start: { line: startLine, character: startCharacter },
                        end: { line: endLine, character: endCharacter },
                    });
                    if (sourceRange) {
                        target += '#L' + (sourceRange.start.line + 1) + ',' + (sourceRange.start.character + 1);
                        target += '-L' + (sourceRange.end.line + 1) + ',' + (sourceRange.end.character + 1);
                        break;
                    }
                }
                else {
                    const sourcePos = map.getSourcePosition({ line: startLine, character: startCharacter });
                    if (sourcePos) {
                        target += '#L' + (sourcePos.line + 1) + ',' + (sourcePos.character + 1);
                        break;
                    }
                }
            }
        }
    }
    return target;
}
exports.transformDocumentLinkTarget = transformDocumentLinkTarget;
//# sourceMappingURL=resolveDocumentLink.js.map